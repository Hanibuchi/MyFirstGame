@startuml MyGame
' skinparam groupInheritance 2
' skinparam linetype polyline

class GameManager {
	+static GameManager Instance
	+static Noitaっぽいげーむ inputActions
	+ResourceManager ResourceManager
	+GameObject EquipmentMenuCanvas;
	+GameObject NPCEquipmentMenuScrollContent;
	+GameObject StatusBar;
	+StatusCanvasSlotsFrame StatusCanvasItemSlotFrame;
	+GameObject Inventory;
	+TerrainManager TerrainManager;
	+Grid Grid;
	+Tilemap TerrainTilemap;
	+GameObject DragContainer;
	+Party PlayerParty;
	+NPCManager PlayerManager;
	+bool IsEquipmentMenuOpen;

	+static int Seed { get; private set; }
	+enum RandomNames
	+static readonly Dictionary<RandomNames, MyRandom> Randoms
	+class MyRandom
	+static class Functions
	+class Utility

	-void Awake()
	+void GenerateSeed()
}
GameManager::Awake --> inputActions : 生成
GameManager::Awake --> inputActions::Enable
GameManager::Awake --> ResourceManager::LoadAssetsAndMakeObjectPools
GameManager::Awake --> Party::InitParty


class ResourceManager {
	+ResourceManager Instance
	+bool IsLoaded { get; private set; }

	+enum ItemIDs
	-static readonly Dictionary<ItemIDs, GameObjectPool> Item
	+GameObject GetItem(ItemIDs)
	+void ReleaseItem(ItemIDs, GameObject)
	+void ClearItem(ItemIDs)

	+enum ProjectileIDs
	-static readonly Dictionary<ProjectileIDs, GameObjectPool> Projectile

	+enum MobIDs
	-static readonly Dictionary<MobIDs, GameObjectPool> Mob
	+GameObject GetMob(MobIDs)
	+void ReleaseMob(MobIDs, GameObject)
	+void ClearMob(MobIDs)

	+enum MapAssetIDs
	+static readonly Dictionary<MapAssetIDs, GameObjectPool> Map

	+enum UIIDs
	+static readonly Dictionary<MapAssetIDs, GameObjectPool> UI

	+enum OtherIDs
	+static readonly Dictionary<OtherIDs, GameObjectPool> Other

	+void Init()

	+Task LoadAssetsAndMakeObjectPools()

	-Task MakeObjectPoolItem()
	-Task MakeObjectPoolProjectile()
	-Task MakeObjectPoolMob()
	-Task MakeObjectPoolMap()
	-Task MakeObjectPoolOther()
}
ResourceManager::GetItem --> ObjectManager::Init
ResourceManager::GetMob --> MobManager::Init

class UIManager {
	+UIManager Instance

}


class GameObjectPool {
	+GameObject Resource
	-ObjectPool<GameObject> Pool
	+GameObjectPool(GameObject prefab, int defaultCapacity, int maxSize, bool collectionChecks = true)
	+GameObject Get()
	+void Release(GameObject prefab)
}

class CameraController {

}

class Party {
	+List<NPCManager> PartyMembers { get; private set; }
	+List<Transform> MemberPos
	+bool IsPlayerParty { get; private set; }
	+void InitParty()
	+void AddMember(NPCManager member)
	+void AddMember(NPCManager member, int index)
	+void ChangeLeader(NPCManager nextLeader)
	-void AssignLeader(NPCManager nextLeader)
	-void DissmissLeader(NPCManager previousLeader)
	+void InsertMember(int index, NPCManager member)
	-void SwitchMembers(NPCManager memberA, NPCManager memberB)
	+void RemoveMember(NPCManager member)
	+void AreAllMembersDead()
	+AddMember(NPCManager member)
}
Party o-- NPCManager

Party::AddMember --> NPCManager::GenerateNPCEquipmentMenu
Party::AddMember --> NPCManager::Party
Party::AssignLeader --> NPCManager::IsLeader : trueにする
Party::AssignLeader --> PlayerController : 生成
Party::DissmissLeader --> NPCManager::IsLeader : falseにする
Party::DissmissLeader --> PlayerController: 削除
Party::InsertMember --> NPCManager::Party
Party::InsertMember --> NPCEquipmentMenu::InsertMember
Party::SwitchMembers --> NPCEquipmentMenu::SwitchMembers
Party::RemoveMember --> NPCManager::Party
Party::RemoveMember --> NPCManager::DestroyEquipmentMenu

interface IDamageable {
	+void TakeDamage(Damage damage, MobManager user, Vector2 direction)*
	+void Die()
}

IDamageable <|.. ObjectManager
IDamageable <|.. TileObjManager
IDamageable <|.. MobManager
IDamageable <|.. NPCManager

interface IStatusAffectable {
	+ bool IsStunned*
	+ bool IsPoisoned*
	+ bool IsFrozen*
	+ bool IsSlowedByCold*
}

IStatusAffectable <|.. ObjectManager
IStatusAffectable <|.. MobManager
IStatusAffectable <|.. NPCManager

class ObjectManager{
	+ObjectStatus Data
	+int ID
	+bool IsDead
	+float BaseMaxHP
	+event Action<float> OnBaseMaxHPChanged
	+float CurrentMaxHP
	+event Action<float> OnCurrentMaxHPChanged
	+float CurrentHP
	+event Action<float> OnCurrentHPChanged
	+Damage BaseResistanceRate
	+event Action<Damage> OnBaseResistanceRateChanged
	+Damage CurrentResistanceRate
	+event Action<Damage> OnCurrentResistanceRateChanged
	#bool IsStunned
	#bool IsPoisoned
	#bool IsFrozen
	#bool IsSlowedByCold
	#void Init(int poolID) // 廃棄予定
	#void Init()
	#void Start()
	#void ResetStatus()
	+Damage TakeDamage(Damage damage, MobManager user, Vector2 direction)
	-void OnCollisionEnter2D(GameObject other)
	-void OnCollisionStay2D(GameObject other)
	#void DetectCollision(Collision2D other)
	#void DetectItemCollision(Collisioin2D other)
	-IncreaseCurrentHP(float additionalHP)
	-void Die()
	+ItemRestoreData MakeRestoreData()
	+void ApplyRestoreData(ItemRestoreData)
}
ObjectManager <|-- MobManager
ObjectManager ..|> IChunkHandler

ObjectManager::Die --> MobManager::AddExperience
' IDamageable::Die --> IDamageable::IsDead
' ObjectManager::TakeDamage --> ObjectManager::IsStunned
' ObjectManager::TakeDamage --> ObjectManager::IsPoisoned
' ObjectManager::TakeDamage --> ObjectManager::IsFrozen
' ObjectManager::TakeDamage --> ObjectManager::IsSlowedByCold
' ObjectManager::OnCollisionEnter2D --> ObjectManager::DetectCollision
' ObjectManager::OnCollisionStay2D --> ObjectManager::DetectCollision
' ObjectManager::Start --> ObjectManager::ResetStatus
' ObjectManager::TakeDamage --> ObjectManager::IncreaseCurrentHP
' ObjectManager::IncreaseCurrentHP --> ObjectManager::Die
' ObjectManager::TakeDamage --> ObjectManager::Die
' ObjectManager::Die --> ObjectManager::IsDead
ObjectManager::DetectCollision --> Projectile::Hit : トリガーはObjectManagerにやらせる
ObjectManager::DetectItemCollision --> Item::MobHit

class ItemRestoreData {

}

class ObjectStatus {
	+ResourceManager.ItemIDs ItemID;
	+float BaseMaxHP;
	+Damage BaseRegistanceRate;
}
ObjectStatus --|> ScriptableObject

class TileObjManager{
	+ChunkManager BossChunkManager
	+Vector3Int Position { get; private set; }
	-TileObjData Data;
	+float MaxHP
	+float CurrentHP
	+Damage ResistanceRate
	+void Init(Vector2Int)
	+void IncreaseCurrentHP(float)
	+void Die()
}
TileObjManager <|.. IDamageable

class TileObjData {
	+ResourceManager.MapAssetIDs
	+float MaxHP
	+Damage RegistanceRate
}
TileObjData <|-- ScriptableObject

class MobManager{
	+LayerMask BaseTargetLayer
	+LayerMask CurrentTargetLayer
	+event Action<LayerMask> OnCurrentTargetLayerChanged
	+float BaseMaxMP
	+event Action<float> OnBaseMaxMPChanged
	+float CurrentMaxMP
	+event Action<float> OnCurrentMaxMPChanged
	+float CurrentMP
	+event Action<float> OnCurrentMPChanged
	+float BaseMPRegen
	+event Action<float> OnBaseMPRegenChanged
	+float CurrentMPRegen
	+event Action<float> OnCurrentMPRegenChanged
	+float BaseLevel
	+event Action<float> OnBaseLevelChanged
	+float CurrentLevel
	+event Action<float> OnCurrentLevelChanged
	+float BaseSpeed
	+event Action<float> OnBaseSpeedChanged
	+List<Items> Items
	-SelectedSlotNumber
	#void Start()
	+void AddExperience(float amount)
	+void IncreaseCurrentMP(float additionalMP)
	+void SetSelectedSlotNumber(int num)
	+void AddSelectedSlotNumber(int num)
	+float Fire(Vector2 target)
	+void ApplyRecoil(Shot shot)
	+void PickupItem()
	+void AddItem(int index, Item item)
	+void ThrowItem(Vector2 target)
	+void ThrowItem(Item item, Vector2 target)
	+void RemoveItem(Item item)
	+void AddItemCapacity*()
	-void LevelUp()
}
MobManager <|-- NPCManager
' MobManager::IncreaseCurrentMP --> MobManager::CurrentMP
MobManager::Fire --> Item::FirstFire
MobManager::ThrowItem --> Item::ThrowItem

' MobManager::PickupItem --> MobManager::AddItemToEmptySlot
' MobManager::AddItemToEmptySlot --> MobManager::AddItem
MobManager::AddItem --> Item::OnPickedUp

MobManager::RemoveItem --> Item::Owner

class MobRestoreData{

}
ItemRestoreData <|-- MobRestoreData

class MobStatus {
	+ResourceManager.MobIDs MobID;
	+LayerMask BasetTargetLayer;
	+float BaseMaxMP;
	+float BasetMPRegen;
	+ulong BaseLevel;
	+float BaseSpeed;
	+Damage BaseDamage;
}
ObjectStatus <|-- MobStatus

class NPCManager{
	+bool IsPlayer { get; }
	+bool IsLeader
	+Party Party
	+Jobs Job { get; private set; }
	+NPCEquipmentMenu EquipmentMenu { get; private set; }

	+event Action<Sprite> OnNPCImageChanged
	+event Action<float> OnBaseMaxHPChanged
	+event Action<float> OnCurrentMaxHPChanged
	+event Action<float> OnCurrentHPChanged
	+event Action<Damage> OnBaseResistanceRateChanged
	+event Action<Damage> OnCurrentResistanceRateChanged
	+event Action<float> OnCurrentMaxMPChanged;
	+event Action<float> OnCurrentMPChanged;
	+event Action<float> OnCurrentLevelChanged
	+event Action<Jobs> OnJobChanged

	+void GenerateNPCEquipmentMenu(int? index)
	+void PickupItem()
	#void Die()
	+void DestroyEquipmentMenu()
	+void InteractNPC()
	#void Start()
}
NPCManager "1" *-- "1" NPCEquipmentMenu
NPCManager::IsPlayer --> Party::IsPlayerParty
NPCManager::GenerateNPCEquipmentMenu --> NPCEquipmentMenu : 生成
NPCManager::GenerateNPCEquipmentMenu --> NPCEquipmentMenu::RegisterStatus
NPCManager::GenerateNPCEquipmentMenu --> StatusBar::RegisterStatus
NPCManager::DestroyEquipmentMenu --> NPCEquipmentMenu : 削除
NPCManager::PickupItem --> Item::AddToInventory
NPCManager::Die --> Party::AreAllMembersDead
NPCManager::InteractNPC --> Party::AddMember

' NPCManager::OnNPCImageChanged --> NPCEquipmentMenu::UpDateNPCImage
' NPCManager::OnCurrentLevelChanged --> NPCEquipmentMenu::UpdateNPCLevel
' NPCManager::OnJobChanged --> NPCEquipmentMenu::UpdateJob
' NPCManager::OnCurrentHPChanged --> NPCEquipmentMenu::UpdateCurrentHP
' NPCManager::OnCurrentMaxHPChanged-->NPCEquipmentMenu::UpdateMaxtHP
' NPCManager::OnCurrentMPChanged -->NPCEquipmentMenu::UpdateCurrentMP
' NPCManager::OnCurrentMaxMPChanged --> NPCEquipmentMenu::UpdateMaxMP

class NPCData{
	+Jobs Job
}
NPCData <|-- MobData

class DropItem
class PlayerController
class EnemyController
class NPCController

MobManager o-- DropItem

NPCManager <-- PlayerController
MobManager <-- EnemyController
NPCManager <-- NPCController

interface INPCStatusUI {
	+void RegisterStatus(NPCManager npcManager)
	+void UnregisterStatus(NPCManager npcManager)
}
INPCStatusUI <|.. NPCEquipmentMenu
INPCStatusUI <|.. StatusBar

class NPCEquipmentMenu {
	+static void InsertMember(NPCEquipmentMenu npcEquipmentMenu, int index)
	+static void SwitchMembers(NPCEquipmentMenu firstNPC, NPCEquipmentMenu secondNPC)

	+void RegisterStatus(NPCManager equipmentMenu)
	+void UnregisterStatus(NPCManager equipmentMenu)
	+void UpDateNPCImage(Sprite newNPCImage)
	+void UpdateNPCName(string newNPCName)
	+void UpdateNPCLevel(float newLevel)
	+void UpdateJob(Jobs newJob)
	+void UpdateCurrentHP(float currentHP)
	+void UpdateMaxtHP(float maxHP)
	+void UpdateCurrentMP(float currentMP)
	+void UpdateMaxMP(float maxMP)
}
class StatusBar {

}

class Slot
class InventorySlot
class EquipmentSlot
class ItemSlot
ItemSlot --> Item

class SlotSpacing
class ContentSizeObserver
class FixedViewportSizeAdjuster
class ItemImageFrame
class ScrollView

NPCEquipmentMenu <|-- StatusCanvas

Slot <|-- InventorySlot
InventorySlot <|-- EquipmentSlot
Slot <|-- ItemSlot

ItemSlot o-- SlotSpacing
SlotSpacing --> ItemSlot

ContentSizeObserver --> FixedViewportSizeAdjuster

ItemImageFrame --> ItemSlot

ScrollView --> NPCManager

GameManager::OnAllAssetsLoaded --> Item::MakeObjectPool

class DragSystem {
	+static DragSystem Instance
	-void Update()
	+void ItemBeginDrag(Item item)
	+void ItemSlotBeginDrag(ItemSlot itemSlot, Item item)
	+void OnOpenEquipmentMenu()
	+void OnCloseEquipmentMenu()
	+void EndDrag()
}
DragSystem::Update --> Item::MoveItem
DragSystem::Update --> ItemSlot::SetAtMousePos
DragSystem::ItenBeginDrag --> Item::BeginDrag
DragSystem::ItemSlotBeginDrag --> ItemSlot::BeginDrag
DragSystem::OnOpenEquipmentMenu --> Item::HideItemAndShowUI
DragSystem::OnOpenEquipmentMenu --> ItemSlot::BeginDrag
DragSystem::OnCloseEquipmentMenu --> Item::ShowItemAndHideUI
DragSystem::OnCloseEquipmentMenu --> Item::BeginDrag
DragSystem::EndDrag --> Item::EndDrag
DragSystem::EndDrag --> ItemSlot::EndDrag

class Item {
	+Owner { get; set; }
	+ItemSlot { get; private set; }
	+Item PrevItem { get; private set; }
	+List<Item> NextItems { get; private set; }
	+int ItemCapacity { get; }
	+float ReloadTime { get; }
	+CoolDownTime { get; private set; }
	+LayerMask TargetLayer { get; }
	+float MP { get; }
	+Damage Damage { get; }
	+float Diffusion { get; }
	+float Speed { get; }
	+float Duration { get; }
	+float Recoil { get; }
	+float AdditionalSize { get; }
	+float AdditionalAmount { get; }
	+bool IsMPSufficient { get; private set; }
	+Vector2 DragOffset
	+bool IsUIDragging

	#Update()
	+void MakeObjectPool()
	+void FirstFire(Shot shot)
	+void Fire(Shot shot)
	#void ModifyParams(Shot shot)
	#void SetNextItems(Shot shot)
	#void ModifyProjectiles(Shot shot)
	+void ThrowItem(Shot shot)
	+void MobHit(ObjectManager objectManager)
	+void OnPickedUp(MobManager owner)
	+void AddToInventory()
	+void ShowItemAndHideUI()
	+ItemSlot HideItemAndShowUI()
	+void PrepareUI()
	+void AddNextItem(Item item)
	+void OnPickedUp(MobManager owner)
	+void CanAddItem(Item item)
	+void OnBeginDrag(PointerEventData eventData)
	+void BeginDrag()
	+void MoveItem()
	+void OnEndDrag(PointerEventData eventData)
	+void EndDrag()
}
Item::FirstFire --> MobManager::IncreaseCurrentMP : MPを消費
Item::ModifyParams --> IParameterModifier::EditParameters
Item::ModifyProjectiles --> IProjectileModifier::EditProjectile
Item::ShowItemAndHideUI --> ItemSlot : リリース
Item::MobHit --> ObjectManager::TakeDamage
Item::PrepareUI --> ItemSlot::Init
Item::PrepareUI --> ItemSlot : 作成
Item::OnBeginDrag --> DragSystem::ItenBeginDrag
Item::OnEndDrag --> DragSystem::EndDrag

Item <|-- AttackItem
Item <|-- ParameterModifierItem
Item <|-- ProjectileModifierItem
Item <|-- ConsumableItem

interface IParameterModifier
{
	+void EditParameters(Shot shot)
}
IParameterModifier <|.. ParameterModifierItem

class ParameterModifierItem {
	+void EditParameters(Shot shot)
}

class AttackItem {
	+void Fire(Shot shot)
	#void ApplyRecoil(Shot shot)
	#void ThrowProjectile(GameObject referenceObject, Shot shot)
}
AttackItem::Fire --> Shot::SetAdditionalValues
AttackItem::Fire --> Item::ModifyParamsAndSetAttackItems
AttackItem::Fire --> Item::ModifyProjectiles
AttackItem::Fire --> AttackItem::ApplyRecoil
AttackItem::Fire --> Item::SetNextItems
AttackItem::ApplyRecoil --> MobManager::ApplyRecoil
AttackItem::ThrowProjectile --> Projectile : 生成

interface IProjectileModifier
{
	+void EditProjectile(Shot shot)
}

IProjectileModifier <|.. ProjectileModifierItem

class ProjectileModifierItem {
	+void EditProjectile(Shot shot)
}
class ConsumableItem
class AddItemCapacityItem {
	+Fire()
}
ConsumableItem <|-- AddItemCapacityItem
AddItemCapacityItem::Fire --> MobManager::AddItemCapacity

class Projectile {
	+Shot Shot
	+void Hit(Collision2D other)
}
Projectile::Hit --> ObjectManager::TakeDamage : 処理はProjectileが主導

class Shot {
	+void SetAdditionalValues()
	+void FireNextItems()
}
class Damage

' UI部分は未記述
class ItemSlot {
	+Item Item

	+void Init(Item newItem, Sprite sprite)
	+void OnBeginDrag(PointerEventData eventData)
	+void BeginDrag()
	+void DragSetUp()
	+void SetAtMousePos()
	+void OnEndDrag(PointerEventData eventData)
	+void EndDrag()
}
ItemSlot::OnBeginDrag --> DragSystem::ItemSlotBeginDrag
ItemSlot::OnEndDrag --> DragSystem::EndDrag
ItemSlot::EndDrag --> Item::AddNextItem

AttackItem o-- Projectile

Shot o-- Damage

DropItem o-- Item

NPCEquipmentMenu o-- EquipmentSlot


class TerrainManager {
	-enum AreaIDs
	-Dictionary<AreaIDs, AreaManager> Areas
	-enum ChunkState
	-Dictionary<Vector2Int, ChunkState> ChunkStates
	+Vector3Int ChunkSize 1チャンクあたり縦横何マスか
	+Vector2 CellSize
	-Vector2 PlayerPos
	+Vector2Int? PlayerChunkpos
	+Vector2 ChunkGenerateRange

	+void Init()

	-void Update()
	+PrepareChunk(Vector2Int chunkPos)
	+UnloadChunk(Vector2Int chunkPos)

	-IEnumerator Generate(Vector2Int chunkPos)
	-IEnumerator Deactivate(Vector2Int chunkPos)
	-IEnumerator Activate(Vector2Int chunkPos)
	-AreaManager GetArea(Vector2Int chunkPos)
	-void Reset()

	+Vector2Int WorldPosToChunkPos(Vector2 pos)
}
TerrainManager::CellSize --> GameManager::Grid
TerrainManager::PlayerPos --> GameManager::PlayerManager
TerrainManager::Generate --> AreaManager::Generate
TerrainManager::Deactivate --> AreaManager::Deactivate
TerrainManager::Activate --> AreaManager::Activate
TerrainManager::Reset --> AreaManager::Reset

class AreaManager {
	-TerrainManager BossTerrainManager
	+bool IsVisited { get; private set; }
	-Dictionary<Vector2Int, ChunkManager> ChunkManagers

	+void Init(TerrainManager)
	+bool Generate(Vector2Int chunkPos)
	-ChunkManager GetChunk(Vector2Int chunkPos)
	+bool Deactivate(Vector2Int chunkPos)
	+bool Activate(Vector2Int chunkPos)
	+void Reset()
}
' AreaManager::Generate --> AreaManager::GetChunk
AreaManager::Generate --> ChunkManager::Generate
AreaManager::Deactivate --> ChunkManager::Deactivate : リリース
AreaManager::Activate --> ChunkManager::Activate
AreaManager::Reset --> ChunkManager::Reset : リリース

AreaManager::GetChunk --> ResourceManager
AreaManager::GetChunk --> ChunkManager::Init : 生成

class ChunkManager {
	-AreaManager BossAreaManager

	-Vector2Int ChunkPos
	-List<IChunkHandler> Handlers
	+static string readonly WorldDataDirectoryPath
	+static string InitialChunkDataDirectoryPath
	#List<string> InitialChunkDataPaths
	+string SavedChunkDataDirectoryPath
	-string SavedChunkDataPath

	+void Init(AreaManager)

	+bool Generate(Vector2Int chunkPos)
	+bool Deactivate()
	-void SaveChunkData()
	+bool Activate(Vector2Int chunkPos)
	+void Reset()

	-void MakeChunkData()

	-void GenerateChunk(ChunkData chunkData)

	-void ClearAllChunkData()

	+void SetTile(Vector3Int, BaseTile baseTile)
	+void DeleteTile(TileObjManager gm)

	-OnTriggerEnter2D()
	-Register(IChunkHandler handler)
	+Unregister(IChunkHandler handler)

	+void CreateChunkDataAsset()
}
note right of ChunkManager::CreateChunkData
マップ作成用。子オブジェクトと与えられた範囲のTilesを記録してChunkDataを作成。
end note
ChunkManager::Generate --> ResourceManager::ChunkDatas
ChunkManager::Deactivate --> BaseTile : 削除
ChunkManager::Activate --> BaseTile : 生成
ChunkManager::Reset --> BaseTile : 削除

ChunkManager::SetTile --> Tilemap::SetTile
ChunkManager::DeleteTile --> TileObjManager : リリース
ChunkManager::DeleteTile --> Tilemap::SetTile : BaseTileをnullに置き換える
ChunkManager::DeleteTile --> ChunkManager::Handlers : remove

ChunkManager::Generate --> IChunkHandler::OnChunkGenerate
ChunkManager::Deactivate --> IChunkHandler::OnChunkDeactivate
ChunkManager::Activate --> IChunkHandler::OnChunkActivate
ChunkManager::Reset --> IChunkHandler::OnChunkReset

ChunkManager::SaveChunkData --> ChunkData : jsonファイル生成

ChunkManager::OnTriggerEnter2D --> ChunkManager::Register
ChunkManager::OnTriggerEnter2D --> ChunkManager::Unregister : BossChunkManagerがnullでなければ勝手にUnregisterする

interface IChunkHandler {
	+ChunkManager BossChunkManager
	+void OnChunkGenerate(ChunkManager)
	+void OnChunkDeactivate(ChunkManager)
	+void OnChunkActivate(ChunkManager)
	+void OnChunkReset(ChunkManager)
}
IChunkHandler <|.. TileObjManager

class ChunkData {
	TileBase[] Tiles
	List<ItemData> Items
	List<MobData> Mobs
}
ChunkData *-- ItemData
ChunkData *-- MobData

class ItemData {
	ResourceManager.ItemIDs
	float HP
	Vector3 LocalPosition
	Vector3 Rotation
	Vector3 Size
}
class MobData {
	ResourceManager.MobIDs
	float HP
	Vector3 LocalPosition
	Vector3 Rotation
	Vector3 Size
}

ChunkData::Tiles o-- BaseTile

class Tilemap {
	+SetTile(Vector3Int pos, TileBase tile)
}
Tilemap::SetTile --> BaseTile::StartUp

RuleTile <|-- BaseTile

class BaseTile {
	-StartUp()
}
BaseTile::StartUp --> TileObjManager::Init: 生成

class TileObjManager {
	+ChunkManager BossChunkManager
	+Init(Vector3Int pos)
	+Die()
}
TileObjManager::Die --> ChunkManager::DeleteTile
@enduml



@startuml ReloadTime
skinparam linetype ortho
class Item {
	+ReloadTime { get; }
	+CoolDownTime { get; }
	+FirstFire(Shot shot)
	#Update()
	-ProcessReloadAndMP(Shot shot)
}
Item::FirstFire --> Item::ProcessReloadAndMP
Item::ProcessReloadAndMP --> Item::ProcessReloadAndMP
Item::ProcessReloadAndMP --> MobManager::IncreaseCurrentMP
Item::ProcessReloadAndMP --> Item::ReloadTime
Item::ProcessReloadAndMP --> Item::CoolDownTime
Item::Update --> Item::CoolDownTime

class MobManager {
	+void IncreaseCurrentMP(float additionalMP)
	+void Fire(Vector2 target)
}
MobManager::Fire --> Item::FirstFire
@enduml



@startuml Add/RemoveItem
class MobManager {
	+List<Item> Item { get; private set; }
	+int ItemCapacity { get; private set; }
	+void PickupItem()
	#List<Collider2D> DetectNearbyColliders(ContactFilter2D filter2D)
	+void AddItem(int index, Item item)
	-void AddItemToEmptySlot(Item item)

	+void ThrowItem(Vector2 target)
	#void RemoveItemWhenThrow(int slotNum)
	+void RemoveItem(int slotNum)
}
MobManager::PickupItem --> MobManager::AddItemToEmptySlot
MobManager::AddItemToEmptySlot --> MobManager::AddItem
MobManager::AddItem --> Item::OnPickedUp
Item::OnPickedUp --> Item::RemovePrevItem
Item::OnPickedUp --> Item::Owner

MobManager::ThrowItem --> MobManager::RemoveItem
MobManager::ThrowItem --> Item::SetActive

' 正確にはplayerPartyの一員
class NPCManager {
	+List<Item> Item { get; private set; }
	+int ItemCapacity { get; private set; }
	+void PickupItem()
	#List<Collider2D> DetectNearbyColliders(ContactFilter2D filter2D)
	+void AddItem(int index, Item item)
	-void AddItemToEmptySlot(Item item)

	+void ThrowItem(Vector2 target)
	#void RemoveItemWhenThrow(int slotNum)
	+void RemoveItem(int slotNum)
}
NPCManager::PickupItem --> NPCManager::AddItemToEmptySlot
NPCManager::PickupItem --> Item::AddToInventory
NPCManager::AddItemToEmptySlot --> NPCManager::AddItem
NPCManager::AddItem --> Item::OnPickedUp
Item::OnPickedUp --> Item::RemovePrevItem
Item::OnPickedUp --> Item::Owner

NPCManager::ThrowItem --> NPCManager::RemoveItem
NPCManager::ThrowItem --> Item::SetActive

class Item {
	+Owner
	+void RemovePrevRelation()
	-void RemovePrevItem()
	-void RemovePrevOwner()
	+void OnPickedUp(MobManager owner)
	+void SetActive(bool)

	+void AddToInventory()
}
Item::RemovePrevRelation --> MobManager::RemoveItem

class AutoSlottingItem {
	-void OnCollisionEnter2D*()
}
note right of AutoSlottingItem: 触れると勝手にスロットに追加されるヤンデレアイテム
AutoSlottingItem::OnCollisionEnter2D --> MobManager::AddItemToEmptySlot
@enduml



@startuml Item
GameManager::OnAllAssetsLoaded --> Item::MakeObjectPool

class DragSystem {
	+static DragSystem Instance
	void Update()
	+void ItemBeginDrag(Item item)
	+void ItemSlotBeginDrag(ItemSlot itemSlot, Item item)
	+void OnOpenEquipmentMenu()
	+void OnCloseEquipmentMenu()
	+void EndDrag()
}
DragSystem::Update --> Item::MoveItem
DragSystem::Update --> ItemSlot::SetAtMousePos
DragSystem::ItenBeginDrag --> Item::BeginDrag
DragSystem::ItemSlotBeginDrag --> ItemSlot::BeginDrag
DragSystem::OnOpenEquipmentMenu --> Item::HideItemAndShowUI
DragSystem::OnOpenEquipmentMenu --> ItemSlot::BeginDrag
DragSystem::OnCloseEquipmentMenu --> Item::ShowItemAndHideUI
DragSystem::OnCloseEquipmentMenu --> Item::BeginDrag
DragSystem::EndDrag --> Item::EndDrag
DragSystem::EndDrag --> ItemSlot::EndDrag

class Item {
	+Owner { get; set; }
	+ItemSlot { get; private set; }
	+Item PrevItem { get; private set; }
	+List<Item> NextItems { get; private set; }
	+int ItemCapacity { get; }
	+float ReloadTime { get; }
	+CoolDownTime { get; private set; }
	+LayerMask TargetLayer { get; }
	+float MP { get; }
	+Damage Damage { get; }
	+float Diffusion { get; }
	+float Speed { get; }
	+float Duration { get; }
	+float Recoil { get; }
	+float AdditionalSize { get; }
	+float AdditionalAmount { get; }
	+bool IsMPSufficient { get; private set; }
	+Vector2 DragOffset
	+bool IsUIDragging

	#Update()
	+void MakeObjectPool()
	+void FirstFire(Shot shot)
	+void Fire(Shot shot)
	#void ModifyParams(Shot shot)
	#void SetNextItems(Shot shot)
	#void ModifyProjectiles(Shot shot)
	+void ThrowItem(Shot shot)
	+void MobHit(ObjectManager objectManager)
	+void OnPickedUp(MobManager owner)
	+void AddToInventory()
	+void ShowItemAndHideUI()
	+ItemSlot HideItemAndShowUI()
	+void PrepareUI()
	+void AddNextItem(Item item)
	+void OnPickedUp(MobManager owner)
	+void CanAddItem(Item item)
	+void OnBeginDrag(PointerEventData eventData)
	+void BeginDrag()
	+void MoveItem()
	+void OnEndDrag(PointerEventData eventData)
	+void EndDrag()
}
Item::FirstFire --> MobManager::IncreaseCurrentMP : MPを消費
Item::ModifyParams --> IParameterModifier::EditParameters
Item::ModifyProjectiles --> IProjectileModifier::EditProjectile
Item::ShowItemAndHideUI --> ItemSlot : リリース
Item::MobHit --> ObjectManager::TakeDamage
Item::PrepareUI --> ItemSlot::Init
Item::PrepareUI --> ItemSlot : 作成
Item::OnBeginDrag --> DragSystem::ItenBeginDrag
Item::OnEndDrag --> DragSystem::EndDrag

Item <|-- AttackItem
Item <|-- ParameterModifierItem
Item <|-- ProjectileModifierItem
Item <|-- ConsumableItem

interface IParameterModifier
{
	+void EditParameters(Shot shot)
}
IParameterModifier <|.. ParameterModifierItem

class ParameterModifierItem {
	+void EditParameters(Shot shot)
}

class AttackItem {
	+void Fire(Shot shot)
	#void ApplyRecoil(Shot shot)
	#void ThrowProjectile(GameObject referenceObject, Shot shot)
}
AttackItem::Fire --> Shot::SetAdditionalValues
AttackItem::Fire --> Item::ModifyParamsAndSetAttackItems
AttackItem::Fire --> Item::ModifyProjectiles
AttackItem::Fire --> AttackItem::ApplyRecoil
AttackItem::Fire --> Item::SetNextItems
AttackItem::ApplyRecoil --> MobManager::ApplyRecoil
AttackItem::ThrowProjectile --> Projectile : 生成

interface IProjectileModifier
{
	+void EditProjectile(Shot shot)
}

IProjectileModifier <|.. ProjectileModifierItem

class ProjectileModifierItem {
	+void EditProjectile(Shot shot)
}
class ConsumableItem
class AddItemCapacityItem {
	+Fire()
}
ConsumableItem <|-- AddItemCapacityItem
AddItemCapacityItem::Fire --> MobManager::AddItemCapacity

class Projectile {
	+Shot Shot
	+void Hit(Collision2D other)
}
Projectile::Hit --> ObjectManager::TakeDamage : 処理はProjectileが主導

class Shot {
	+void SetAdditionalValues()
	+void FireNextItems()
}
class Damage

' UI部分は未記述
class ItemSlot {
	+Item Item

	+void Init(Item newItem, Sprite sprite)
	+void OnBeginDrag(PointerEventData eventData)
	+void BeginDrag()
	+void DragSetUp()
	+void SetAtMousePos()
	+void OnEndDrag(PointerEventData eventData)
	+void EndDrag()
}
ItemSlot::OnBeginDrag --> DragSystem::ItemSlotBeginDrag
ItemSlot::OnEndDrag --> DragSystem::EndDrag
ItemSlot::EndDrag --> Item::AddNextItem

AttackItem o-- Projectile

Shot o-- Damage
@enduml

@startuml Terrain
class TerrainManager {
	-enum AreaIDs
	-Dictionary<AreaIDs, AreaManager> Areas
	-enum ChunkState
	-Dictionary<Vector2Int, ChunkState> ChunkStates
	+Vector3Int ChunkSize 1チャンクあたり縦横何マスか
	+Vector2 CellSize
	-Vector2 PlayerPos
	+Vector2Int? PlayerChunkpos
	+Vector2 ChunkGenerateRange

	+void Init()

	-void Update()
	+PrepareChunk(Vector2Int chunkPos)
	+UnloadChunk(Vector2Int chunkPos)

	-IEnumerator Generate(Vector2Int chunkPos)
	-IEnumerator Deactivate(Vector2Int chunkPos)
	-IEnumerator Activate(Vector2Int chunkPos)
	-AreaManager GetArea(Vector2Int chunkPos)
	-void Reset()

	+Vector2Int WorldPosToChunkPos(Vector2 pos)
}
TerrainManager::CellSize --> GameManager::Grid
TerrainManager::PlayerPos --> GameManager::PlayerManager
TerrainManager::Generate --> AreaManager::Generate
TerrainManager::Deactivate --> AreaManager::Deactivate
TerrainManager::Activate --> AreaManager::Activate
TerrainManager::Reset --> AreaManager::Reset

class AreaManager {
	-TerrainManager BossTerrainManager
	+bool IsVisited { get; private set; }
	-Dictionary<Vector2Int, ChunkManager> ChunkManagers

	+void Init(TerrainManager)
	+bool Generate(Vector2Int chunkPos)
	-ChunkManager GetChunk(Vector2Int chunkPos)
	+bool Deactivate(Vector2Int chunkPos)
	+bool Activate(Vector2Int chunkPos)
	+void Reset()
}
' AreaManager::Generate --> AreaManager::GetChunk
AreaManager::Generate --> ChunkManager::Generate
AreaManager::Deactivate --> ChunkManager::Deactivate : リリース
AreaManager::Activate --> ChunkManager::Activate
AreaManager::Reset --> ChunkManager::Reset : リリース

AreaManager::GetChunk --> ResourceManager
AreaManager::GetChunk --> ChunkManager::Init : 生成

class ChunkManager {
	-AreaManager BossAreaManager

	-Vector2Int ChunkPos
	-List<IChunkHandler> Handlers
	+static string readonly WorldDataDirectoryPath
	+static string InitialChunkDataDirectoryPath
	#List<string> InitialChunkDataPaths
	+string SavedChunkDataDirectoryPath
	-string SavedChunkDataPath

	+void Init(AreaManager)

	+bool Generate(Vector2Int chunkPos)
	+bool Deactivate()
	-void SaveChunkData()
	+bool Activate(Vector2Int chunkPos)
	+void Reset()

	-void MakeChunkData()

	-void GenerateChunk(ChunkData chunkData)

	-void ClearAllChunkData()

	+void SetTile(Vector3Int, BaseTile baseTile)
	+void DeleteTile(TileObjManager gm)

	-OnTriggerEnter2D()
	-Register(IChunkHandler handler)
	+Unregister(IChunkHandler handler)

	+void CreateChunkDataAsset()
}
note right of ChunkManager::CreateChunkData
マップ作成用。子オブジェクトと与えられた範囲のTilesを記録してChunkDataを作成。
end note
ChunkManager::Generate --> ResourceManager::ChunkDatas
ChunkManager::Deactivate --> BaseTile : 削除
ChunkManager::Activate --> BaseTile : 生成
ChunkManager::Reset --> BaseTile : 削除

ChunkManager::SetTile --> Tilemap::SetTile
ChunkManager::DeleteTile --> TileObjManager : リリース
ChunkManager::DeleteTile --> Tilemap::SetTile : BaseTileをnullに置き換える
ChunkManager::DeleteTile --> ChunkManager::Handlers : remove

ChunkManager::Generate --> IChunkHandler::OnChunkGenerate
ChunkManager::Deactivate --> IChunkHandler::OnChunkDeactivate
ChunkManager::Activate --> IChunkHandler::OnChunkActivate
ChunkManager::Reset --> IChunkHandler::OnChunkReset

ChunkManager::SaveChunkData --> ChunkData : jsonファイル生成

ChunkManager::OnTriggerEnter2D --> ChunkManager::Register
ChunkManager::OnTriggerEnter2D --> ChunkManager::Unregister : BossChunkManagerがnullでなければ勝手にUnregisterする

interface IChunkHandler {
	+ChunkManager BossChunkManager
	+void OnChunkGenerate(ChunkManager)
	+void OnChunkDeactivate(ChunkManager)
	+void OnChunkActivate(ChunkManager)
	+void OnChunkReset(ChunkManager)
}
IChunkHandler <|.. TileObjManager

class ChunkData {
	TileBase[] Tiles
	List<ItemData> Items
	List<MobData> Mobs
}
ChunkData *-- ItemData
ChunkData *-- MobData

class ItemData {
	ResourceManager.ItemIDs
	float HP
	Vector3 LocalPosition
	Vector3 Rotation
	Vector3 Size
}
class MobData {
	ResourceManager.MobIDs
	float HP
	Vector3 LocalPosition
	Vector3 Rotation
	Vector3 Size
}

ChunkData::Tiles o-- BaseTile

class Tilemap {
	+SetTile(Vector3Int pos, TileBase tile)
}
Tilemap::SetTile --> BaseTile::StartUp

RuleTile <|-- BaseTile

class BaseTile {
	-StartUp()
}
BaseTile::StartUp --> TileObjManager::Init: 生成

class TileObjManager {
	+ChunkManager BossChunkManager
	+Init(Vector3Int pos)
	+Die()
}
TileObjManager::Die --> ChunkManager::DeleteTile
@enduml

@startuml Status
enum StatusID{}

interface IStatusAffectable {
	+List<Status> StatusList { get; }
	+Action<float> MoveAction { get; set; }
	+SetMoveAction(Action<float> action)
	+Status AddStatus(Status.StatusID id)
	+DurationStatus AddDurationStatus(Status.StatusID id, float duration)
	+WetStatus AddWetStatus(Status.StatusID id, float wetLevel)
}
IStatusAffectable::AddStatus --> Status::Add
IStatusAffectable::MoveAction o-- WetStatus::ChangeWetLevel

class Status {
	+StatusID ID { get; private set; }
	-List<Status> StatusList
	#bool CanAdd(List<Status>)
	+Add(StatusID, List<Status>)
	+Expire()
}

class DurationStatus {
	+float Duration
	+IEnumerator Add(StatusID id, float duration, List<Status> statusList)
	+SetDuration(float duration)
	+AddDuration(float duration)
}
Status <|-- DurationStatus

class WetStatus {
	+float WetLevel
	+float MovementDryRate
	+float NaturalDryRate
	+IStatusAffectable StatusAffectable
	+bool Add(StatusID id, float wetLevel, IStatusAffectable statusAffectable)
	+SetWetLevel(float)
	+IEnumerator StartTimedDry()
	+ChangeWetLevelBySpeed(float speed)
	+ChangeWetLevel(float)
}
Status <|-- WetStatus
WetStatus::Add --> IStatusAffectable::SetMoveAction

class MoveObserverForWetStatus {
	-Update()
}
MoveObserverForWetStatus::Update --> IStatusAffectable::MoveAction


@enduml


@startuml UI

GameManager --> UIManager::Init
class UIManager {
	+Init()
}
UIManager::Init --> EquipmentMenuManager::ToggleEquipmentMenu

class UI {
	+ResourceManager.UIIDs ID { get; protected set;}
	+OnGet(int id)
	+OnRelease()
}
IResourceHandler <|.. UI

NPCManager::GenerateNPCEquipmentMenu --> EquipmentMenuManager::InsertMember
Party::SwitchMembers --> EquipmentMenuManager::SwitchMembers
PlayerController::ToggleEquipmentMenu --> EquipmentMenuManager::ToggleEquipmentMenu

class EquipmentMenuManager {
	+InsertMember()
	+InsertMember(NPCEquipmentMenu npcEquipmentMenu)
	+SwitchMembers(NPCEquipmentMenu npc1, NPCEquipmentMenu npc2)
	+RemoveMember(NPCEquipmentMenu npcEquipmentMenu)
	+bool ToggleEquipmentMenu()
}
EquipmentMenuManager::InsertMember --> NPCEquipmentMenuFrame::InsertMember
EquipmentMenuManager::SwitchMembers --> NPCEquipmentMenuFrame::SwitchMembers
EquipmentMenuManager::RemoveMember --> NPCEquipmentMenuFrame::RemoveMember

interface INPCStatusUI {
	+void RegisterStatus(NPCManager npcManager)
	+void UnregisterStatus()
}
class StatusBar
UI <|-- StatusBar
INPCStatusUI <|.. StatusBar

class NPCEquipmentMenuFrame {
	+void InsertMember(NPCEquipmentMenu npcEquipmentMenu, int index)
	+void SwitchMembers(NPCEquipmentMenu npc1, NPCEquipmentMenu npc2)
	+RemoveMember(NPCEquipmentMenu npcEquipmentMenu)
}
UI <|-- NPCEquipmentMenuFrame
NPCEquipmentMenuFrame *-- NPCEquipmentMenu

class NPCEquipmentMenu {

}
NPCEquipmentMenu::OnRelease --> EquipmentMenuManager::RemoveMember
UI <|-- NPCEquipmentMenu
INPCStatusUI <|.. NPCEquipmentMenu
@enduml


@startuml KeyBindingsCD
class GameInputs

class InputSystem{
	+enum State {None, Rebinding}
	+State State

	+enum ActionType

	delegate void RebindDelegate(InputAction inputAction, int index)

	+StartRebind(InputAction inputAction, int index, RebindDelegate callback, RebindDelegate cancelCallback, RebindDelegate deleteCallback, RebindDelegate resetCallback)
	+Delete(InputAction inputAction, int index)
	-EndRebind()
	+Cancel()
	+ResetKeyBind(InputAction inputAction, int index)
}
InputSystem::Cancel --> KeyBindingsController::Cancel
InputSystem::EndRebind --> KeyBindingsController::EndRebind
InputSystem::Delete --> KeyBindingsController::Delete
InputSystem::ResetKeyBind --> KeyBindingsController::ResetKeyBind

class KeyBindingsController {
	-InputAction inputAction
	-int index
	+Init()
	+StartRebind(InputSystem.ActionType action, int index)
	-EndRebind(InputAction inputAction, int index)
	-Cancel(InputAction inputAction, int index)
	-Delete(InputAction inputAction, int index)
	-ResetKeyBind(InputAction inputAction, int index)
}
KeyBindingsController::StartRebind --> InputSystem::StartRebind
KeyBindingsController::EndRebind --> InputSystem::StartRebind : 引数に入れる
KeyBindingsController::Cancel --> InputSystem::StartRebind: 引数に入れる

KeyBindingsController::Init --> KeyBindingsUI::Init
KeyBindingsController::EndRebind --> KeyBindingsUI::SetKeyName
KeyBindingsController::Cancel --> KeyBindingsUI::SetKeyName
KeyBindingsController::Delete --> KeyBindingsUI::Delete
KeyBindingsController::ResetKeyBind --> KeyBindingsUI::SetKeyName

class KeyBindingsUI {
	delegate void RebindUIDelegate(InputSystem.ActionType actionName, int index)
	-class ActionNamesAndKeyBindUIPair
	-List<ActionNamesAndKeyBindUIPair> ActionNamesAndKeyBindUIPairs
	-Dictionary<InputSystem.ActionType, KeyBindingEntryUI> KeyBindingEntryUIs
	-KeyBindingEntryUI rebindingActionUI
	+Init(RebindUIDelegate onStartReind)
	+StartRebind(InputSystem.ActionType action, int index) ここでrebindingActionUIを登録
	+EndRebind(string keyPath)
	+Cancel()
	+Delete()
	+ResetKeyBind(string name)
}
KeyBindingsUI::StartRebind --> KeyBindingsController::StartRebind

class KeyBindingEntryUI {
	+int MaxKeyNum
	+InputSystem.ActionType ActionType { get; private set; }
	+List<KeyBindingKeyUI> KeyBindingKeyUIs
	-KeyBindingKeyUI rebindingBind;
	-List<string> KeyPaths
	+Init(KeyBindingsUI keyBindingsUI, InputSystem.ActionType actionName, int maxKeyNum)
	+StartRebind(int index)
	+EndRebind(string keyPath)
	+Cancel()
	+Delete()
	+ResetKeyBind(string name)
	+Add()
}
KeyBindingEntryUI::StartRebind --> KeyBindingsUI::StartRebind

class KeyBindingKeyUI {
	+KeyBindingEntryUI BossKeyBindingEntryUI { get; private set; }
	+int Index { get; private set; }
	+Init(KeyBindingEntryUI keyBindingEntry, int index, string key)
	+SetIndex(int index)
	+StartRebind()
	+SetKeyName(string key)
	+Delete()
}
KeyBindingKeyUI::StartRebind --> KeyBindingEntryUI::StartRebind
@enduml

@startuml KeyBindingsSD
participant InputSystem order 0
participant KeyBindingsController order 10
participant KeyBindingsUI order 20
participant KeyBindingEntryUI order 30
participant KeyBindingKeyUI order 40
==Initialization==
KeyBindingsController -> KeyBindingsUI : Init(RebindUIDelegate onStartReind)
KeyBindingsUI -> KeyBindingEntryUI : Init(KeyBindingsUI keyBindingsUI, InputSystem.ActionType action, int maxKeyNum)
KeyBindingEntryUI -> KeyBindingKeyUI : Init(KeyBindingEntryUI keyBindingEntry, int index, string key)

==Rebinding==
KeyBindingKeyUI -> KeyBindingEntryUI : StartRebind(int index)
KeyBindingEntryUI -> KeyBindingsUI : StartRebind(InputSystem.ActionType action, int index)
KeyBindingsUI -> KeyBindingsController : StartRebind(InputSystem.ActionType action, int index)
KeyBindingsController -> InputSystem : StartRebind(IA iA, int ind, RD cb, RD cCb, RD dCb, RD rCb)

alt Rebind case
	InputSystem -> KeyBindingsController : EndRebind(InputAction inputAction, int index)
	KeyBindingsController -> KeyBindingsUI : EndRebind(string keyPath)
	KeyBindingsUI -> KeyBindingEntryUI : EndRebind(string keyPath)
	KeyBindingEntryUI -> KeyBindingKeyUI : SetKeyName(string name)
else Cancel
	InputSystem -> KeyBindingsController: Cancel(InputAction inputAction, int index)
	KeyBindingsController -> KeyBindingsUI : Cancel()
	KeyBindingsUI -> KeyBindingEntryUI : Cancel()
	KeyBindingEntryUI -> KeyBindingKeyUI : SetKeyName(string name)
else Delete
	InputSystem -> KeyBindingsController : Delete(InputAction inputAction, int index)
	KeyBindingsController -> KeyBindingsUI: Delete()
	KeyBindingsUI -> KeyBindingEntryUI : Delete()
	KeyBindingEntryUI -> KeyBindingKeyUI : Delete()
else Initialization
	InputSystem -> KeyBindingsController: ResetKeyBind(InputAction inputAction, int index)
	KeyBindingsController -> KeyBindingsUI: ResetKeyBind(string name)
	KeyBindingsUI -> KeyBindingEntryUI : ResetKeyBind(string name)
	KeyBindingEntryUI -> KeyBindingKeyUI : SetKeyName(string name)
end
@enduml

@startuml 主要コンポネントの初期化などのタイミングについて
==Application Start==
ApplicationManager -> ApplicationManager : OnAppStart() GameData以下Config, Saves, GlobalData作成
ApplicationManager -> ResourceManager : OnAppStart()
ResourceManager -> ApplicationManager : OnResourceReady()
ApplicationManager -> UIManager : OnAppStart()
ApplicationManager -> AchievementsManager : OnAppStart()
ApplicationManager -> InputSystem : OnAppStart()
ApplicationManager -> KeyBindingsController : OnAppStart() : キーバインドの保存
==CreateNewWorld==
ApplicationManager -> ApplicationManager : LoadScene("MainGameScene")
GameManager -> ApplicationManager : SetGameManager(GameManager gameManager)
ApplicationManager -> GameManager : CreateNewWorld(initialWorldData initialWorldData)
GameManager -> UIManager : OnGameStart()
GameManager -> TerrainManager : NewGame()
GameManager -> PlayerManager : Init()
GameManager -> PlayerParty : NewGame(NPCManager npcManager)
GameManager -> ApplicationManager : OnGameInitializationComplete()
==Return to Title==
ApplicationManager -> ApplicationManager : ReturnToTitle()
ApplicationManager -> GameManager : Save()
GameManager -> TerrainManager : MakeTerrainData()
TerrainManager --> GameManager : TerrainData terrainData
GameManager -> PlayerParty : MakePlayerPartyData()
PlayerParty --> GameManager : PlayerPartyData playerPartyData
GameManager -> GameManager : MakeGameData()
GameManager --> GameManager : GameData gameData
==Quit==
alt Playing case
	ApplicationManager -> GameManager : Save()
end
ApplicationManager -> ApplicationManager : Save()
==LoadWorld==
ApplicationManager -> ApplicationManager : LoadScene("MainGameScene")
GameManager -> ApplicationManager : SetGameManager(GameManager gameManager)
ApplicationManager -> GameManager : LoadWorld(string dataPath)
GameManager -> UIManager : GameStart()
GameManager -> TerrainManager : LoadWorld(TerrainData terrainData)
GameManager -> PlayerParty : LoadWorld(PlayerPartyData playerPartyData)
GameManager -> ApplicationManager : OnGameInitializationComplete()
@enduml

@startuml 主要コンポネントのクラス図
@enduml